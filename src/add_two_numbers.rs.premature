// Warning!! This solution is cloudy-minded, cuz I reversed the solution!!!
// It took four hours to work out this reversal, till Adham inspired the recognition
// that it's unnecessary and wrong.

// This code is "locked" (StackOverflow style :P), though, cuz I learned some cool techniques
// writing it... This is my unsentimental gratitude...

#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
    pub val: i32,
    pub next: Option<Box<ListNode>>,
}

impl ListNode {
    #[inline]
    fn new(val: i32) -> Self {
        ListNode { next: None, val }
    }
}

impl<'a> IntoIterator for &'a ListNode {
    type Item = i32;
    type IntoIter = ListNodeIterator<'a>;

    fn into_iter(self) -> Self::IntoIter {
        ListNodeIterator {
            val: Some(self.val),
            next: &self.next,
        }
    }
}

pub struct ListNodeIterator<'a> {
    val: Option<i32>,
    next: &'a Option<Box<ListNode>>,
}

impl<'a> Iterator for ListNodeIterator<'a> {
    type Item = i32;

    fn next(&mut self) -> Option<Self::Item> {
        let val = self.val;
        match self.next {
            None => self.val = None,
            Some(listNode) => {
                self.next = &listNode.next;
                self.val = Some(listNode.val);
            }
        }
        val
    }
}

pub fn solve(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
    if let Some(list1) = l1 {
        if let Some(list2) = l2 {
            // return Some(add_em_up(list1, list2);
        }
    }

    None
}

fn add_em_up(mut l1: Box<ListNode>, mut l2: Box<ListNode>) -> Box<ListNode> {
    // if they are not of the same length, reduce it to the same-length case, then add what remains

    let len1: i32 = l1.into_iter().map(|x| 1).sum();
    let len2: i32 = l2.into_iter().map(|x| 1).sum();

    let (bigger, bigger_len);
    let (smaller, smaller_len);

    if len1 > len2 {
        bigger = &mut l1;
        bigger_len = len1;
        smaller = &mut l2;
        smaller_len = len2;
    } else {
        bigger = &mut l2;
        bigger_len = len2;
        smaller = &mut l1;
        smaller_len = len1;
    }

    let mut bigger_pointer = bigger.as_mut();
    let mut bigger_pointer_minus_one;
    for i in smaller_len..bigger_len {
        bigger_pointer = bigger.next.as_mut().unwrap();
    }

    let mut carry = add_in_parallel(bigger_pointer, smaller);

    if carry && smaller_len != bigger_len {
        carry = add_one(bigger, bigger_len - smaller_len);
    }

    let mut complete_result;

    if carry {
        complete_result = ListNode
    }

    let mut complete_result: Box<ListNode>;
    if smaller_len == bigger_len {
        if result.1 {
            complete_result = ListNode::new(1).into();
            complete_result.next = Some(result.0.into());
        } else {
            complete_result = result.0.into();
        }
    } else {
        // we modify the bigger list!
        complete_result = if len1 == bigger_len { l1 } else { l2 };

        if result.1 {
            let carry = add_one(&mut complete_result, bigger_len - smaller_len);
            if carry {
                let mut node = ListNode::new(1);
                node.next = Some(complete_result);
                complete_result = node.into();
            }
        }
    }

    complete_result
}

fn add_in_parallel(l1: &mut ListNode, l2: &ListNode) -> bool {
    // (new node with addition, carry)
    // recursive solution!
    // result[i] = x[i] + y[i] + carry_from(x[i+1] + y[i+i])
    // assuming same length

    let mut carry = false;

    if let Some(a) = l1.next.as_mut() {
        if let Some(b) = l2.next.as_ref() {
            carry = add_in_parallel(a, b);
        }
    }

    let val = l1.val + l2.val + if carry { 1 } else { 0 };
    let (val, carry) = if val > 9 {
        (val - 10, true)
    } else {
        (val, false)
    };

    l1.val = val;
    carry
}

fn add_one(mut from: &mut ListNode, to: i32) -> bool {
    // list[i] = list[i] + carry_from(list[i+1] + 1)
    for _ in 0..to {
        from.val += if add_one(from.next.as_mut().unwrap(), to - 1) {
            1
        } else {
            0
        };
    }

    if from.val == 10 {
        from.val -= 1;
        true
    } else {
        false
    }
}
